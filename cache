#!/venv/api/bin/python

from functools import partial
from http.server import HTTPServer, BaseHTTPRequestHandler
from pickle import dumps, loads
from queue import Queue
from signal import signal, sigwait, SIGTERM, SIGQUIT, SIGINT
from sys import exit
from threading import Thread

from requests import post

from rebase.cache import CacheProcess


class RequestHandler(BaseHTTPRequestHandler):
    q = Queue()
    def do_POST(self):
        self.send_response(200)
        self.end_headers()
        content_len = int(self.headers['content-length'], 0)
        post_body = self.rfile.read(content_len)
        task = loads(post_body)
        print('Received task: {}'.format(task))
        self.q.put(task)


def quit(sig, frame, server, processes):
    server.shutdown()
    for process in processes.values():
        process.q.put({'action': 'QUIT'})
        process.join()
    exit()

def main_thread():
    processes = dict()
    server = HTTPServer(('0.0.0.0', 5000), RequestHandler)
    _quit = partial(quit, server=server, processes=processes)
    signal(SIGTERM, _quit)
    signal(SIGQUIT, _quit)
    signal(SIGINT, _quit)
    ip, port = server.server_address

    server_thread = Thread(target=server.serve_forever)
    server_thread.daemon = True
    server_thread.start()
    print("Cache HTTP server is listening in thread:", server_thread.name)
    print('sending POST')
    post(
        'http://127.0.0.1:5000',
        data=dumps({
            'id': (3, 17),
            'action': 'warmup'
        })
    )
    while True:
        task = RequestHandler.q.get()
        RequestHandler.q.task_done()
        print('Got this task from q: {}'.format(task))
        _id  = task['id']
        # processes may timeout if no action is sent to them for a while,
        # so we need to keep the 'processes' dict up-to-date
        processes = dict(filter(lambda _id, process: process.is_alive(), processes))
        if _id not in processes:
            processes[_id] = CacheProcess(_id)
            print('Processes: {}'.format(processes))
        processes[_id].q.put(task)


if __name__ == '__main__':
    main_thread()
